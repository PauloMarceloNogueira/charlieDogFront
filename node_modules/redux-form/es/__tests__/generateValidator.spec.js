"use strict";

var _generateValidator2 = _interopRequireDefault(require("../generateValidator"));

var _plain = _interopRequireDefault(require("../structure/plain"));

var _expectations = _interopRequireDefault(require("../structure/plain/__tests__/expectations"));

var _immutable = _interopRequireDefault(require("../structure/immutable"));

var _expectations2 = _interopRequireDefault(require("../structure/immutable/__tests__/expectations"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var describeGenerateValidator = function describeGenerateValidator(name, structure, setup) {
  var fromJS = structure.fromJS;

  var required = function required(value) {
    return value == null ? 'Required' : undefined;
  };

  var minValue = function minValue(min) {
    return function (value) {
      return value && value < min ? 'Too low' : undefined;
    };
  };

  var withProps = function withProps(value, values, props) {
    return props.valid ? undefined : 'Invalid';
  };

  var withName = function withName(validatorName) {
    return function (value, values, props, name) {
      return validatorName === name ? undefined : 'Invalid name';
    };
  };

  describe(name, function () {
    beforeAll(function () {
      setup();
    });
    it('should return a function', function () {
      var validator = (0, _generateValidator2.default)({}, structure);
      expect(typeof validator).toBe('function');
    });
    it('should always pass validation when no validators given', function () {
      var validator = (0, _generateValidator2.default)({}, structure);
      expect(validator(fromJS({}))).toEqual({});
      expect(validator(fromJS({
        foo: 42,
        bar: 43
      }))).toEqual({});
    });
    it('should validate simple fields', function () {
      var requiredSpy = jest.fn(required);
      var minValueSpy = jest.fn(minValue(4));
      var validator = (0, _generateValidator2.default)({
        foo: requiredSpy,
        bar: minValueSpy
      }, structure);
      expect(requiredSpy).not.toHaveBeenCalled();
      expect(minValueSpy).not.toHaveBeenCalled();
      var values1 = fromJS({});
      var result = validator(values1);
      expect(requiredSpy).toHaveBeenCalled();
      expect(requiredSpy).toHaveBeenCalledTimes(1);
      expect(requiredSpy.mock.calls[0][0]).toBe(undefined);
      expect(requiredSpy.mock.calls[0][1]).toEqual(values1);
      expect(minValueSpy).toHaveBeenCalled();
      expect(minValueSpy).toHaveBeenCalledTimes(1);
      expect(minValueSpy.mock.calls[0][0]).toBe(undefined);
      expect(minValueSpy.mock.calls[0][1]).toEqual(values1);
      expect(result).toEqual({
        foo: 'Required'
      });
      var values2 = fromJS({
        foo: 'Hello',
        bar: 3
      });
      var result2 = validator(values2);
      expect(requiredSpy).toHaveBeenCalledTimes(2);
      expect(requiredSpy.mock.calls[1][0]).toBe('Hello');
      expect(requiredSpy.mock.calls[1][1]).toEqual(values2);
      expect(minValueSpy).toHaveBeenCalledTimes(2);
      expect(minValueSpy.mock.calls[1][0]).toBe(3);
      expect(minValueSpy.mock.calls[1][1]).toEqual(values2);
      expect(result2).toEqual({
        bar: 'Too low'
      });
      var values3 = fromJS({
        foo: 'Hello',
        bar: 4
      });
      var result3 = validator(values3);
      expect(requiredSpy).toHaveBeenCalledTimes(3);
      expect(requiredSpy.mock.calls[2][0]).toBe('Hello');
      expect(requiredSpy.mock.calls[2][1]).toEqual(values3);
      expect(minValueSpy).toHaveBeenCalledTimes(3);
      expect(minValueSpy.mock.calls[2][0]).toBe(4);
      expect(minValueSpy.mock.calls[2][1]).toEqual(values3);
      expect(result3).toEqual({});
    });
    it('allows validation to refer to props', function () {
      var withPropsSpy = jest.fn(withProps);
      var props1 = {
        valid: false
      };
      var props2 = {
        valid: true
      };
      var validator = (0, _generateValidator2.default)({
        foo: withPropsSpy
      }, structure);
      expect(withPropsSpy).not.toHaveBeenCalled();
      var values = fromJS({});
      var result1 = validator(values, props1);
      expect(withPropsSpy).toHaveBeenCalled();
      expect(withPropsSpy).toHaveBeenCalledTimes(1);
      expect(withPropsSpy.mock.calls[0][0]).toBe(undefined);
      expect(withPropsSpy.mock.calls[0][1]).toEqual(values);
      expect(withPropsSpy.mock.calls[0][2]).toEqual(props1);
      expect(result1).toEqual({
        foo: 'Invalid'
      });
      var result2 = validator(values, props2);
      expect(withPropsSpy).toHaveBeenCalledTimes(2);
      expect(withPropsSpy.mock.calls[1][0]).toBe(undefined);
      expect(withPropsSpy.mock.calls[1][1]).toEqual(values);
      expect(withPropsSpy.mock.calls[1][2]).toEqual(props2);
      expect(result2).toEqual({});
    });
    it('allows validation to refer to field name', function () {
      var _generateValidator;

      var name = 'foobar';
      var withNameSpy = jest.fn(withName(name));
      var validator = (0, _generateValidator2.default)((_generateValidator = {}, _generateValidator[name] = withNameSpy, _generateValidator), structure);
      expect(withNameSpy).not.toHaveBeenCalled();
      var values = fromJS({});
      var result1 = validator(values);
      expect(withNameSpy).toHaveBeenCalled();
      expect(withNameSpy).toHaveBeenCalledTimes(1);
      expect(withNameSpy.mock.calls[0][0]).toBe(undefined);
      expect(withNameSpy.mock.calls[0][1]).toEqual(values);
      expect(withNameSpy.mock.calls[0][2]).toEqual(undefined);
      expect(withNameSpy.mock.calls[0][3]).toEqual(name);
      expect(result1).toEqual({});
    });
    it('should validate deep fields', function () {
      var requiredSpy = jest.fn(required);
      var minValueSpy = jest.fn(minValue(4));
      var validator = (0, _generateValidator2.default)({
        'deep.foo': requiredSpy,
        'even.deeper.bar': minValueSpy
      }, structure);
      expect(requiredSpy).not.toHaveBeenCalled();
      expect(minValueSpy).not.toHaveBeenCalled();
      var result = validator(fromJS({}));
      expect(requiredSpy).toHaveBeenCalled();
      expect(requiredSpy).toHaveBeenCalledTimes(1);
      expect(requiredSpy.mock.calls[0][0]).toBe(undefined);
      expect(requiredSpy.mock.calls[0][1]).toEqual(fromJS({}));
      expect(minValueSpy).toHaveBeenCalled();
      expect(minValueSpy).toHaveBeenCalledTimes(1);
      expect(minValueSpy.mock.calls[0][0]).toBe(undefined);
      expect(minValueSpy.mock.calls[0][1]).toEqual(fromJS({}));
      expect(result).toEqual({
        deep: {
          foo: 'Required'
        }
      });
      var values2 = fromJS({
        deep: {
          foo: 'Hello'
        },
        even: {
          deeper: {
            bar: 3
          }
        }
      });
      var result2 = validator(values2);
      expect(requiredSpy).toHaveBeenCalledTimes(2);
      expect(requiredSpy.mock.calls[1][0]).toBe('Hello');
      expect(requiredSpy.mock.calls[1][1]).toEqual(values2);
      expect(minValueSpy).toHaveBeenCalledTimes(2);
      expect(minValueSpy.mock.calls[1][0]).toBe(3);
      expect(minValueSpy.mock.calls[1][1]).toEqual(values2);
      expect(result2).toEqual({
        even: {
          deeper: {
            bar: 'Too low'
          }
        }
      });
      var values3 = fromJS({
        deep: {
          foo: 'Hello'
        },
        even: {
          deeper: {
            bar: 4
          }
        }
      });
      var result3 = validator(values3);
      expect(requiredSpy).toHaveBeenCalledTimes(3);
      expect(requiredSpy.mock.calls[2][0]).toBe('Hello');
      expect(requiredSpy.mock.calls[2][1]).toEqual(values3);
      expect(minValueSpy).toHaveBeenCalledTimes(3);
      expect(minValueSpy.mock.calls[2][0]).toBe(4);
      expect(minValueSpy.mock.calls[2][1]).toEqual(values3);
      expect(result3).toEqual({});
    });
    it('should accept multiple validators', function () {
      var requiredSpy = jest.fn(required);
      var minValueSpy = jest.fn(minValue(4));
      var validator = (0, _generateValidator2.default)({
        foo: [requiredSpy, minValueSpy]
      }, structure);
      expect(requiredSpy).not.toHaveBeenCalled();
      expect(minValueSpy).not.toHaveBeenCalled();
      var values1 = fromJS({});
      var result1 = validator(values1);
      expect(requiredSpy).toHaveBeenCalled();
      expect(requiredSpy).toHaveBeenCalledTimes(1);
      expect(requiredSpy.mock.calls[0][0]).toBe(undefined);
      expect(requiredSpy.mock.calls[0][1]).toEqual(values1);
      expect(minValueSpy).not.toHaveBeenCalled(); // because required errored

      expect(result1).toEqual({
        foo: 'Required'
      });
      var values2 = fromJS({
        foo: '3'
      });
      var result2 = validator(values2);
      expect(requiredSpy).toHaveBeenCalledTimes(2);
      expect(requiredSpy.mock.calls[1][0]).toBe('3');
      expect(requiredSpy.mock.calls[1][1]).toEqual(values2);
      expect(minValueSpy).toHaveBeenCalled();
      expect(minValueSpy).toHaveBeenCalledTimes(1);
      expect(minValueSpy.mock.calls[0][0]).toBe('3');
      expect(minValueSpy.mock.calls[0][1]).toEqual(values2);
      expect(result2).toEqual({
        foo: 'Too low'
      });
      var values3 = fromJS({
        foo: '4'
      });
      var result3 = validator(values3);
      expect(requiredSpy).toHaveBeenCalledTimes(3);
      expect(requiredSpy.mock.calls[2][0]).toBe('4');
      expect(requiredSpy.mock.calls[2][1]).toEqual(values3);
      expect(minValueSpy).toHaveBeenCalledTimes(2);
      expect(minValueSpy.mock.calls[1][0]).toBe('4');
      expect(minValueSpy.mock.calls[1][1]).toEqual(values3);
      expect(result3).toEqual({});
    });
  });
};

describeGenerateValidator('generateValidator.plain', _plain.default, function () {
  return expect.extend(_expectations.default);
});
describeGenerateValidator('generateValidator.immutable', _immutable.default, function () {
  return expect.extend(_expectations2.default);
});