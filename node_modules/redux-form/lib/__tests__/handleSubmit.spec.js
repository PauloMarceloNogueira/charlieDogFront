"use strict";

var _noop2 = _interopRequireDefault(require("lodash/noop"));

var _handleSubmit = _interopRequireDefault(require("../handleSubmit"));

var _SubmissionError = _interopRequireDefault(require("../SubmissionError"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

describe('handleSubmit', function () {
  it('should stop if sync validation fails', function () {
    var values = {
      foo: 'bar',
      baz: 42
    };
    var submit = jest.fn().mockImplementation(function () {
      return 69;
    });
    var startSubmit = jest.fn();
    var stopSubmit = jest.fn();
    var touch = jest.fn();
    var setSubmitFailed = jest.fn();
    var setSubmitSucceeded = jest.fn();
    var asyncValidate = jest.fn();
    var props = {
      startSubmit: startSubmit,
      stopSubmit: stopSubmit,
      touch: touch,
      setSubmitFailed: setSubmitFailed,
      setSubmitSucceeded: setSubmitSucceeded,
      values: values
    };
    (0, _handleSubmit.default)(submit, props, false, asyncValidate, ['foo', 'baz']);
    expect(submit).not.toHaveBeenCalled();
    expect(startSubmit).not.toHaveBeenCalled();
    expect(stopSubmit).not.toHaveBeenCalled();
    expect(touch).toHaveBeenCalledWith('foo', 'baz');
    expect(asyncValidate).not.toHaveBeenCalled();
    expect(setSubmitSucceeded).not.toHaveBeenCalled();
    expect(setSubmitFailed).toHaveBeenCalledWith('foo', 'baz');
  });
  it('should stop and return errors if sync validation fails', function () {
    var values = {
      foo: 'bar',
      baz: 42
    };
    var submit = jest.fn().mockImplementation(function () {
      return 69;
    });
    var syncErrors = {
      foo: 'error'
    };
    var startSubmit = jest.fn();
    var stopSubmit = jest.fn();
    var touch = jest.fn();
    var setSubmitFailed = jest.fn();
    var setSubmitSucceeded = jest.fn();
    var asyncValidate = jest.fn();
    var props = {
      startSubmit: startSubmit,
      stopSubmit: stopSubmit,
      touch: touch,
      setSubmitFailed: setSubmitFailed,
      setSubmitSucceeded: setSubmitSucceeded,
      syncErrors: syncErrors,
      values: values
    };
    var result = (0, _handleSubmit.default)(submit, props, false, asyncValidate, ['foo', 'baz']);
    expect(asyncValidate).not.toHaveBeenCalled();
    expect(submit).not.toHaveBeenCalled();
    expect(startSubmit).not.toHaveBeenCalled();
    expect(stopSubmit).not.toHaveBeenCalled();
    expect(touch).toHaveBeenCalledWith('foo', 'baz');
    expect(setSubmitSucceeded).not.toHaveBeenCalled();
    expect(setSubmitFailed).toHaveBeenCalledWith('foo', 'baz');
    expect(result).toEqual(syncErrors);
  });
  it('should return result of sync submit', function () {
    var values = {
      foo: 'bar',
      baz: 42
    };
    var submit = jest.fn().mockImplementation(function () {
      return 69;
    });
    var dispatch = _noop2.default;
    var startSubmit = jest.fn();
    var stopSubmit = jest.fn();
    var touch = jest.fn();
    var setSubmitFailed = jest.fn();
    var setSubmitSucceeded = jest.fn();
    var asyncValidate = undefined;
    var props = {
      dispatch: dispatch,
      startSubmit: startSubmit,
      stopSubmit: stopSubmit,
      touch: touch,
      setSubmitFailed: setSubmitFailed,
      setSubmitSucceeded: setSubmitSucceeded,
      values: values
    };
    expect((0, _handleSubmit.default)(submit, props, true, asyncValidate, ['foo', 'baz'])).toBe(69);
    expect(submit).toHaveBeenCalledWith(values, dispatch, props);
    expect(startSubmit).not.toHaveBeenCalled();
    expect(stopSubmit).not.toHaveBeenCalled();
    expect(touch).toHaveBeenCalledWith('foo', 'baz');
    expect(setSubmitFailed).not.toHaveBeenCalled();
    expect(setSubmitSucceeded).toHaveBeenCalled();
  });
  it('should not submit if async validation fails', function () {
    var values = {
      foo: 'bar',
      baz: 42
    };
    var submit = jest.fn().mockImplementation(function () {
      return 69;
    });
    var dispatch = _noop2.default;
    var startSubmit = jest.fn();
    var stopSubmit = jest.fn();
    var touch = jest.fn();
    var setSubmitFailed = jest.fn();
    var setSubmitSucceeded = jest.fn();
    var asyncValidate = jest.fn().mockImplementation(function () {
      return Promise.resolve(values);
    });
    var props = {
      dispatch: dispatch,
      startSubmit: startSubmit,
      stopSubmit: stopSubmit,
      touch: touch,
      setSubmitFailed: setSubmitFailed,
      setSubmitSucceeded: setSubmitSucceeded,
      values: values
    };
    return (0, _handleSubmit.default)(submit, props, true, asyncValidate, ['foo', 'baz']).then(function () {
      throw new Error('Expected to fail');
    }).catch(function (result) {
      expect(result).toBe(values);
      expect(asyncValidate).toHaveBeenCalledWith();
      expect(submit).not.toHaveBeenCalled();
      expect(startSubmit).not.toHaveBeenCalled();
      expect(stopSubmit).not.toHaveBeenCalled();
      expect(touch).toHaveBeenCalledWith('foo', 'baz');
      expect(setSubmitSucceeded).not.toHaveBeenCalled();
      expect(setSubmitFailed).toHaveBeenCalledWith('foo', 'baz');
    });
  });
  it('should call onSubmitFail with async errors and dispatch if async validation fails and onSubmitFail is defined', function () {
    var values = {
      foo: 'bar',
      baz: 42
    };
    var submit = jest.fn().mockImplementation(function () {
      return 69;
    });
    var dispatch = _noop2.default;
    var startSubmit = jest.fn();
    var stopSubmit = jest.fn();
    var onSubmitFail = jest.fn();
    var touch = jest.fn();
    var setSubmitFailed = jest.fn();
    var setSubmitSucceeded = jest.fn();
    var asyncValidate = jest.fn().mockImplementation(function () {
      return Promise.resolve(values);
    });
    var props = {
      dispatch: dispatch,
      onSubmitFail: onSubmitFail,
      startSubmit: startSubmit,
      stopSubmit: stopSubmit,
      touch: touch,
      setSubmitFailed: setSubmitFailed,
      setSubmitSucceeded: setSubmitSucceeded,
      values: values
    };
    return (0, _handleSubmit.default)(submit, props, true, asyncValidate, ['foo', 'baz']).then(function () {
      throw new Error('Expected to fail');
    }).catch(function (result) {
      expect(result).toBe(values);
      expect(asyncValidate).toHaveBeenCalledWith();
      expect(submit).not.toHaveBeenCalled();
      expect(startSubmit).not.toHaveBeenCalled();
      expect(stopSubmit).not.toHaveBeenCalled();
      expect(onSubmitFail).toHaveBeenCalled();
      expect(onSubmitFail.mock.calls[0][0]).toEqual(values);
      expect(onSubmitFail.mock.calls[0][1]).toEqual(dispatch);
      expect(onSubmitFail.mock.calls[0][2]).toBe(null);
      expect(onSubmitFail.mock.calls[0][3]).toEqual(props);
      expect(touch).toHaveBeenCalledWith('foo', 'baz');
      expect(setSubmitSucceeded).not.toHaveBeenCalled();
      expect(setSubmitFailed).toHaveBeenCalledWith('foo', 'baz');
    });
  });
  it('should not submit if async validation fails and return rejected promise', function () {
    var values = {
      foo: 'bar',
      baz: 42
    };
    var submit = jest.fn().mockImplementation(function () {
      return 69;
    });
    var dispatch = _noop2.default;
    var startSubmit = jest.fn();
    var stopSubmit = jest.fn();
    var touch = jest.fn();
    var setSubmitFailed = jest.fn();
    var setSubmitSucceeded = jest.fn();
    var asyncErrors = {
      foo: 'async error'
    };
    var asyncValidate = jest.fn().mockImplementation(function () {
      return Promise.reject(asyncErrors);
    });
    var props = {
      dispatch: dispatch,
      startSubmit: startSubmit,
      stopSubmit: stopSubmit,
      touch: touch,
      setSubmitFailed: setSubmitFailed,
      setSubmitSucceeded: setSubmitSucceeded,
      values: values
    };
    return (0, _handleSubmit.default)(submit, props, true, asyncValidate, ['foo', 'baz']).then(function () {
      throw new Error('Expected to fail');
    }).catch(function (result) {
      expect(result).toBe(asyncErrors);
      expect(asyncValidate).toHaveBeenCalledWith();
      expect(submit).not.toHaveBeenCalled();
      expect(startSubmit).not.toHaveBeenCalled();
      expect(stopSubmit).not.toHaveBeenCalled();
      expect(touch).toHaveBeenCalledWith('foo', 'baz');
      expect(setSubmitSucceeded).not.toHaveBeenCalled();
      expect(setSubmitFailed).toHaveBeenCalledWith('foo', 'baz');
    });
  });
  it('should sync submit if async validation passes', function () {
    var values = {
      foo: 'bar',
      baz: 42
    };
    var submit = jest.fn().mockImplementation(function () {
      return 69;
    });
    var dispatch = _noop2.default;
    var startSubmit = jest.fn();
    var stopSubmit = jest.fn();
    var touch = jest.fn();
    var setSubmitFailed = jest.fn();
    var setSubmitSucceeded = jest.fn();
    var asyncValidate = jest.fn().mockImplementation(function () {
      return Promise.resolve();
    });
    var props = {
      dispatch: dispatch,
      startSubmit: startSubmit,
      stopSubmit: stopSubmit,
      touch: touch,
      setSubmitFailed: setSubmitFailed,
      setSubmitSucceeded: setSubmitSucceeded,
      values: values
    };
    return (0, _handleSubmit.default)(submit, props, true, asyncValidate, ['foo', 'baz']).then(function (result) {
      expect(result).toBe(69);
      expect(asyncValidate).toHaveBeenCalledWith();
      expect(submit).toHaveBeenCalledWith(values, dispatch, props);
      expect(startSubmit).not.toHaveBeenCalled();
      expect(stopSubmit).not.toHaveBeenCalled();
      expect(touch).toHaveBeenCalledWith('foo', 'baz');
      expect(setSubmitFailed).not.toHaveBeenCalled();
      expect(setSubmitSucceeded).toHaveBeenCalled();
    });
  });
  it('should async submit if async validation passes', function () {
    var values = {
      foo: 'bar',
      baz: 42
    };
    var submit = jest.fn().mockImplementation(function () {
      return Promise.resolve(69);
    });
    var dispatch = _noop2.default;
    var startSubmit = jest.fn();
    var stopSubmit = jest.fn();
    var touch = jest.fn();
    var setSubmitFailed = jest.fn();
    var setSubmitSucceeded = jest.fn();
    var asyncValidate = jest.fn().mockImplementation(function () {
      return Promise.resolve();
    });
    var props = {
      dispatch: dispatch,
      startSubmit: startSubmit,
      stopSubmit: stopSubmit,
      touch: touch,
      setSubmitFailed: setSubmitFailed,
      setSubmitSucceeded: setSubmitSucceeded,
      values: values
    };
    return (0, _handleSubmit.default)(submit, props, true, asyncValidate, ['foo', 'baz']).then(function (result) {
      expect(result).toBe(69);
      expect(asyncValidate).toHaveBeenCalledWith();
      expect(submit).toHaveBeenCalledWith(values, dispatch, props);
      expect(startSubmit).toHaveBeenCalled();
      expect(stopSubmit).toHaveBeenCalledWith();
      expect(touch).toHaveBeenCalledWith('foo', 'baz');
      expect(setSubmitFailed).not.toHaveBeenCalled();
      expect(setSubmitSucceeded).toHaveBeenCalled();
    });
  });
  it('should set submit errors if async submit fails', function () {
    var values = {
      foo: 'bar',
      baz: 42
    };
    var submitErrors = {
      foo: 'submit error'
    };
    var submit = jest.fn().mockImplementation(function () {
      return Promise.reject(new _SubmissionError.default(submitErrors));
    });
    var dispatch = _noop2.default;
    var startSubmit = jest.fn();
    var stopSubmit = jest.fn();
    var touch = jest.fn();
    var setSubmitFailed = jest.fn();
    var setSubmitSucceeded = jest.fn();
    var asyncValidate = jest.fn().mockImplementation(function () {
      return Promise.resolve();
    });
    var props = {
      dispatch: dispatch,
      startSubmit: startSubmit,
      stopSubmit: stopSubmit,
      touch: touch,
      setSubmitFailed: setSubmitFailed,
      setSubmitSucceeded: setSubmitSucceeded,
      values: values
    };
    return (0, _handleSubmit.default)(submit, props, true, asyncValidate, ['foo', 'baz']).then(function (error) {
      expect(error).toBe(submitErrors);
      expect(asyncValidate).toHaveBeenCalledWith();
      expect(submit).toHaveBeenCalledWith(values, dispatch, props);
      expect(startSubmit).toHaveBeenCalled();
      expect(stopSubmit).toHaveBeenCalledWith(submitErrors);
      expect(touch).toHaveBeenCalledWith('foo', 'baz');
      expect(setSubmitFailed).toHaveBeenCalled();
      expect(setSubmitSucceeded).not.toHaveBeenCalled();
    });
  });
  it('should not set errors if rejected value not a SubmissionError', function () {
    var values = {
      foo: 'bar',
      baz: 42
    };
    var submitErrors = {
      foo: 'submit error'
    };
    var submit = jest.fn().mockImplementation(function () {
      return Promise.reject(submitErrors);
    });
    var dispatch = _noop2.default;
    var startSubmit = jest.fn();
    var stopSubmit = jest.fn();
    var touch = jest.fn();
    var setSubmitFailed = jest.fn();
    var setSubmitSucceeded = jest.fn();
    var asyncValidate = jest.fn().mockImplementation(function () {
      return Promise.resolve();
    });
    var props = {
      dispatch: dispatch,
      startSubmit: startSubmit,
      stopSubmit: stopSubmit,
      touch: touch,
      setSubmitFailed: setSubmitFailed,
      setSubmitSucceeded: setSubmitSucceeded,
      values: values
    };
    var resolveSpy = jest.fn();
    var errorSpy = jest.fn();
    return (0, _handleSubmit.default)(submit, props, true, asyncValidate, ['foo', 'baz']).then(resolveSpy, errorSpy).then(function () {
      expect(resolveSpy).not.toHaveBeenCalled();
      expect(errorSpy).toHaveBeenCalledWith(submitErrors);
      expect(asyncValidate).toHaveBeenCalledWith();
      expect(submit).toHaveBeenCalledWith(values, dispatch, props);
      expect(startSubmit).toHaveBeenCalled();
      expect(stopSubmit).toHaveBeenCalledWith(undefined); // not wrapped in SubmissionError

      expect(touch).toHaveBeenCalledWith('foo', 'baz');
      expect(setSubmitFailed).toHaveBeenCalled();
      expect(setSubmitSucceeded).not.toHaveBeenCalled();
    });
  });
  it('should set submit errors if async submit fails and return rejected promise', function () {
    var values = {
      foo: 'bar',
      baz: 42
    };
    var submitErrors = {
      foo: 'submit error'
    };
    var submit = jest.fn().mockImplementation(function () {
      return Promise.reject(new _SubmissionError.default(submitErrors));
    });
    var dispatch = _noop2.default;
    var startSubmit = jest.fn();
    var stopSubmit = jest.fn();
    var touch = jest.fn();
    var setSubmitFailed = jest.fn();
    var setSubmitSucceeded = jest.fn();
    var asyncValidate = jest.fn().mockImplementation(function () {
      return Promise.resolve();
    });
    var props = {
      dispatch: dispatch,
      startSubmit: startSubmit,
      stopSubmit: stopSubmit,
      touch: touch,
      setSubmitFailed: setSubmitFailed,
      setSubmitSucceeded: setSubmitSucceeded,
      values: values
    };
    return (0, _handleSubmit.default)(submit, props, true, asyncValidate, ['foo', 'baz']).then(function (error) {
      expect(error).toBe(submitErrors);
      expect(asyncValidate).toHaveBeenCalledWith();
      expect(submit).toHaveBeenCalledWith(values, dispatch, props);
      expect(startSubmit).toHaveBeenCalled();
      expect(stopSubmit).toHaveBeenCalledWith(submitErrors);
      expect(touch).toHaveBeenCalledWith('foo', 'baz');
      expect(setSubmitFailed).toHaveBeenCalled();
      expect(setSubmitSucceeded).not.toHaveBeenCalled();
    });
  });
  it('should submit when there are old submit errors and persistentSubmitErrors is enabled', function () {
    var values = {
      foo: 'bar',
      baz: 42
    };
    var submit = jest.fn().mockImplementation(function () {
      return 69;
    });
    var startSubmit = jest.fn();
    var stopSubmit = jest.fn();
    var touch = jest.fn();
    var setSubmitFailed = jest.fn();
    var setSubmitSucceeded = jest.fn();
    var asyncValidate = jest.fn();
    var props = {
      startSubmit: startSubmit,
      stopSubmit: stopSubmit,
      touch: touch,
      setSubmitFailed: setSubmitFailed,
      setSubmitSucceeded: setSubmitSucceeded,
      values: values,
      persistentSubmitErrors: true
    };
    (0, _handleSubmit.default)(submit, props, true, asyncValidate, ['foo', 'baz']);
    expect(submit).toHaveBeenCalled();
  });
  it('should not swallow errors', function () {
    var values = {
      foo: 'bar',
      baz: 42
    };
    var submit = jest.fn().mockImplementation(function () {
      throw new Error('spline reticulation failed');
    });
    var startSubmit = jest.fn();
    var stopSubmit = jest.fn();
    var touch = jest.fn();
    var setSubmitFailed = jest.fn();
    var setSubmitSucceeded = jest.fn();
    var asyncValidate = jest.fn();
    var props = {
      startSubmit: startSubmit,
      stopSubmit: stopSubmit,
      touch: touch,
      setSubmitFailed: setSubmitFailed,
      setSubmitSucceeded: setSubmitSucceeded,
      values: values
    };
    expect(function () {
      return (0, _handleSubmit.default)(submit, props, true, asyncValidate, ['foo', 'baz']);
    }).toThrow('spline reticulation failed');
    expect(submit).toHaveBeenCalled();
  });
  it('should not swallow async errors', function () {
    var values = {
      foo: 'bar',
      baz: 42
    };
    var submit = jest.fn().mockImplementation(function () {
      return Promise.reject(new Error('spline reticulation failed'));
    });
    var startSubmit = jest.fn();
    var stopSubmit = jest.fn();
    var touch = jest.fn();
    var setSubmitFailed = jest.fn();
    var setSubmitSucceeded = jest.fn();
    var asyncValidate = jest.fn();
    var props = {
      startSubmit: startSubmit,
      stopSubmit: stopSubmit,
      touch: touch,
      setSubmitFailed: setSubmitFailed,
      setSubmitSucceeded: setSubmitSucceeded,
      values: values
    };
    var resultSpy = jest.fn();
    var errorSpy = jest.fn();
    return (0, _handleSubmit.default)(submit, props, true, asyncValidate, ['foo', 'baz']).then(resultSpy, errorSpy).then(function () {
      expect(submit).toHaveBeenCalled();
      expect(resultSpy).not.toHaveBeenCalled();
      expect(errorSpy).toHaveBeenCalled();
    });
  });
  it('should not swallow async errors when form is invalid', function () {
    var values = {
      foo: 'bar',
      baz: 42
    };
    var submit = jest.fn().mockImplementation(function () {
      return 69;
    });
    var syncErrors = {
      baz: 'sync error'
    };
    var asyncErrors = {
      foo: 'async error'
    };
    var startSubmit = jest.fn();
    var stopSubmit = jest.fn();
    var touch = jest.fn();
    var setSubmitFailed = jest.fn();
    var setSubmitSucceeded = jest.fn();
    var asyncValidate = jest.fn();
    var props = {
      startSubmit: startSubmit,
      stopSubmit: stopSubmit,
      touch: touch,
      setSubmitFailed: setSubmitFailed,
      setSubmitSucceeded: setSubmitSucceeded,
      syncErrors: syncErrors,
      asyncErrors: asyncErrors,
      values: values
    };
    var result = (0, _handleSubmit.default)(submit, props, false, asyncValidate, ['foo', 'baz']);
    expect(asyncValidate).not.toHaveBeenCalled();
    expect(submit).not.toHaveBeenCalled();
    expect(startSubmit).not.toHaveBeenCalled();
    expect(stopSubmit).not.toHaveBeenCalled();
    expect(touch).toHaveBeenCalledWith('foo', 'baz');
    expect(setSubmitSucceeded).not.toHaveBeenCalled();
    expect(setSubmitFailed).toHaveBeenCalledWith('foo', 'baz');
    expect(result).toEqual(_extends({}, asyncErrors, syncErrors));
  });
});