"use strict";

var _react = _interopRequireWildcard(require("react"));

var _reactRedux = require("react-redux");

var _redux = require("redux");

var _reduxImmutablejs = require("redux-immutablejs");

var _testUtils = _interopRequireDefault(require("react-dom/test-utils"));

var _createReduxForm = _interopRequireDefault(require("../createReduxForm"));

var _createReducer = _interopRequireDefault(require("../createReducer"));

var _createField = _interopRequireDefault(require("../createField"));

var _Form = _interopRequireDefault(require("../Form"));

var _plain = _interopRequireDefault(require("../structure/plain"));

var _expectations = _interopRequireDefault(require("../structure/plain/__tests__/expectations"));

var _immutable = _interopRequireDefault(require("../structure/immutable"));

var _expectations2 = _interopRequireDefault(require("../structure/immutable/__tests__/expectations"));

var _SubmissionError = _interopRequireDefault(require("../SubmissionError"));

var _actions = _interopRequireDefault(require("../actions"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var change = _actions.default.change,
    clearSubmit = _actions.default.clearSubmit,
    setSubmitFailed = _actions.default.setSubmitFailed,
    setSubmitSucceeded = _actions.default.setSubmitSucceeded,
    submit = _actions.default.submit,
    touch = _actions.default.touch,
    updateSyncErrors = _actions.default.updateSyncErrors;

var propsAtNthRender = function propsAtNthRender(componentSpy, callNumber) {
  return componentSpy.mock.calls[callNumber][0];
};

var describeForm = function describeForm(name, structure, combineReducers, setup) {
  var reduxForm = (0, _createReduxForm.default)(structure);
  var Field = (0, _createField.default)(structure);
  var reducer = (0, _createReducer.default)(structure);
  var fromJS = structure.fromJS,
      getIn = structure.getIn;

  var makeStore = function makeStore(initial, logger) {
    if (initial === void 0) {
      initial = {};
    }

    var reducers = {
      form: reducer
    };

    if (logger) {
      reducers.logger = logger;
    }

    return (0, _redux.createStore)(combineReducers(reducers), fromJS({
      form: initial
    }));
  };

  describe(name, function () {
    beforeAll(function () {
      setup();
    });
    it('should throw an error if not in ReduxForm', function () {
      expect(function () {
        _testUtils.default.renderIntoDocument(_react.default.createElement("div", null, _react.default.createElement(_Form.default, {
          onSubmit: function onSubmit() {}
        })));
      }).toThrow(/must be inside a component decorated with reduxForm/);
    });
    it('should output a <form> element with all props mapped', function () {
      var store = makeStore({
        testForm: {
          values: {
            foo: 42
          }
        }
      });
      var onSubmit = jest.fn();

      var TestForm =
      /*#__PURE__*/
      function (_Component) {
        _inheritsLoose(TestForm, _Component);

        function TestForm() {
          return _Component.apply(this, arguments) || this;
        }

        var _proto = TestForm.prototype;

        _proto.render = function render() {
          return _react.default.createElement(_Form.default, {
            onSubmit: onSubmit,
            action: "/save",
            method: "post",
            target: "_blank",
            rel: "noopener noreferrer"
          }, _react.default.createElement(Field, {
            name: "foo",
            component: "input"
          }));
        };

        return TestForm;
      }(_react.Component);

      var DecoratedTestForm = reduxForm({
        form: 'testForm'
      })(TestForm);

      var dom = _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(DecoratedTestForm, null)));

      expect(onSubmit).not.toHaveBeenCalled();

      var tag = _testUtils.default.findRenderedDOMComponentWithTag(dom, 'form'); // ðŸ¤¢ Is there a better way to get the props on the <form> ??


      var props = tag[Object.keys(tag)[1]];
      expect(props.onSubmit).toBe(onSubmit);
      expect(props.action).toBe('/save');
      expect(props.method).toBe('post');
      expect(props.target).toBe('_blank');
    });
    it('should call the onSubmit given to <Form> when instance API submit() is called', function () {
      var store = makeStore({
        testForm: {
          values: {
            foo: 42
          }
        }
      });
      var onSubmit = jest.fn().mockImplementation(function () {
        return 7;
      });

      var ref = _react.default.createRef();

      var TestForm =
      /*#__PURE__*/
      function (_Component2) {
        _inheritsLoose(TestForm, _Component2);

        function TestForm() {
          return _Component2.apply(this, arguments) || this;
        }

        var _proto2 = TestForm.prototype;

        _proto2.render = function render() {
          return _react.default.createElement(_Form.default, {
            onSubmit: this.props.handleSubmit(onSubmit)
          }, _react.default.createElement(Field, {
            name: "foo",
            component: "input"
          }));
        };

        return TestForm;
      }(_react.Component);

      var DecoratedTestForm = reduxForm({
        form: 'testForm'
      })(TestForm);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(DecoratedTestForm, {
        ref: ref
      })));

      expect(onSubmit).not.toHaveBeenCalled();
      var result = ref.current.submit();
      expect(result).toBe(7);
      expect(onSubmit).toHaveBeenCalled();
      expect(onSubmit).toHaveBeenCalledTimes(1);
      expect(onSubmit.mock.calls[0][0]).toEqualMap({
        foo: 42
      });
      expect(typeof onSubmit.mock.calls[0][1]).toBe('function');
      expect(onSubmit.mock.calls[0][2].values).toEqualMap({
        foo: 42
      });
    });
    it('should call the onSubmit given to <Form> when SUBMIT action is dispatched', function () {
      var store = makeStore({
        testForm: {
          values: {
            foo: 42
          }
        }
      });
      var onSubmit = jest.fn();

      var TestForm =
      /*#__PURE__*/
      function (_Component3) {
        _inheritsLoose(TestForm, _Component3);

        function TestForm() {
          return _Component3.apply(this, arguments) || this;
        }

        var _proto3 = TestForm.prototype;

        _proto3.render = function render() {
          return _react.default.createElement(_Form.default, {
            onSubmit: this.props.handleSubmit(onSubmit)
          }, _react.default.createElement(Field, {
            name: "foo",
            component: "input"
          }));
        };

        return TestForm;
      }(_react.Component);

      var DecoratedTestForm = reduxForm({
        form: 'testForm'
      })(TestForm);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(DecoratedTestForm, null)));

      expect(onSubmit).not.toHaveBeenCalled();
      store.dispatch(submit('testForm'));
      expect(onSubmit).toHaveBeenCalled();
      expect(onSubmit).toHaveBeenCalledTimes(1);
      expect(onSubmit.mock.calls[0][0]).toEqualMap({
        foo: 42
      });
      expect(typeof onSubmit.mock.calls[0][1]).toBe('function');
      expect(onSubmit.mock.calls[0][2].values).toEqualMap({
        foo: 42
      });
    });
    it('should properly handle submission errors', function () {
      var store = makeStore({
        testForm: {
          values: {
            foo: 42
          }
        }
      });
      var onSubmit = jest.fn().mockImplementation(function () {
        throw new _SubmissionError.default({
          _error: 'Invalid'
        });
      });
      var formRender = jest.fn();

      var ref = _react.default.createRef();

      var TestForm =
      /*#__PURE__*/
      function (_Component4) {
        _inheritsLoose(TestForm, _Component4);

        function TestForm() {
          return _Component4.apply(this, arguments) || this;
        }

        var _proto4 = TestForm.prototype;

        _proto4.render = function render() {
          formRender(this.props);
          return _react.default.createElement(_Form.default, {
            onSubmit: this.props.handleSubmit(onSubmit)
          }, _react.default.createElement(Field, {
            name: "foo",
            component: "input"
          }));
        };

        return TestForm;
      }(_react.Component);

      var DecoratedTestForm = reduxForm({
        form: 'testForm'
      })(TestForm);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(DecoratedTestForm, {
        ref: ref
      })));

      expect(formRender).toHaveBeenCalled();
      expect(formRender).toHaveBeenCalledTimes(1);
      expect(onSubmit).not.toHaveBeenCalled();
      ref.current.submit();
      expect(onSubmit).toHaveBeenCalled();
      expect(onSubmit).toHaveBeenCalledTimes(1);
      expect(onSubmit.mock.calls[0][0]).toEqualMap({
        foo: 42
      });
      expect(typeof onSubmit.mock.calls[0][1]).toBe('function');
      expect(onSubmit.mock.calls[0][2].values).toEqualMap({
        foo: 42
      });
      expect(formRender).toHaveBeenCalledTimes(3);
      expect(formRender.mock.calls[2][0].error).toBe('Invalid');
    });
    it('should NOT submit a form with sync validation errors', function () {
      var logger = jest.fn(function (state) {
        if (state === void 0) {
          state = {};
        }

        return state;
      });
      var store = makeStore({}, logger);
      var inputRender = jest.fn(function (props) {
        return _react.default.createElement("input", props.input);
      });
      var onSubmit = jest.fn();
      var formRender = jest.fn();

      var validate = function validate(values) {
        var errors = {};

        if (!getIn(values, 'foo')) {
          errors.foo = 'Required';
        }

        return errors;
      };

      var TestForm =
      /*#__PURE__*/
      function (_Component5) {
        _inheritsLoose(TestForm, _Component5);

        function TestForm() {
          return _Component5.apply(this, arguments) || this;
        }

        var _proto5 = TestForm.prototype;

        _proto5.render = function render() {
          formRender(this.props);
          return _react.default.createElement(_Form.default, {
            onSubmit: this.props.handleSubmit(onSubmit)
          }, _react.default.createElement(Field, {
            name: "foo",
            component: inputRender
          }));
        };

        return TestForm;
      }(_react.Component);

      var DecoratedTestForm = reduxForm({
        form: 'testForm',
        validate: validate
      })(TestForm);

      _testUtils.default.renderIntoDocument(_react.default.createElement(_reactRedux.Provider, {
        store: store
      }, _react.default.createElement(DecoratedTestForm, null)));

      var callIndex = logger.mock.calls.length; // form renders before sync validation and then again with invalid flag

      expect(formRender).toHaveBeenCalledTimes(2);
      expect(propsAtNthRender(formRender, 0).invalid).toBe(false);
      expect(propsAtNthRender(formRender, 1).invalid).toBe(true);
      expect(propsAtNthRender(formRender, 1).submitFailed).toBe(false); // try to submit invalid form via dispatching submit action

      store.dispatch(submit('testForm')); // check that submit action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(submit('testForm')); // check that clear submit action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(clearSubmit('testForm')); // check that touch action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(touch('testForm', 'foo')); // check that setSubmitFailed action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(setSubmitFailed('testForm', 'foo')); // form rerendered twice, once with submit trigger, and then after submit failure

      expect(formRender).toHaveBeenCalledTimes(4);
      expect(propsAtNthRender(formRender, 3).invalid).toBe(true);
      expect(propsAtNthRender(formRender, 3).submitFailed).toBe(true); // update input

      inputRender.mock.calls[0][0].input.onChange('hello'); // check that change action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(change('testForm', 'foo', 'hello', false, false)); // check that updateSyncErrors action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(updateSyncErrors('testForm', {})); // rerendered once to flip dirty flag, and again to flip invalid flag

      expect(formRender).toHaveBeenCalledTimes(6);
      expect(propsAtNthRender(formRender, 3).dirty).toBe(false);
      expect(propsAtNthRender(formRender, 4).dirty).toBe(true);
      expect(propsAtNthRender(formRender, 4).invalid).toBe(true);
      expect(propsAtNthRender(formRender, 5).invalid).toBe(false);
      expect(propsAtNthRender(formRender, 5).submitFailed).toBe(true); // dispatch submit action on now valid form

      store.dispatch(submit('testForm')); // check that submit action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(submit('testForm')); // check that clear submit action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(clearSubmit('testForm')); // check that touch action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(touch('testForm', 'foo')); // check that submit succeeded action was dispatched

      expect(logger.mock.calls[callIndex++][1]).toEqual(setSubmitSucceeded('testForm')); // check no additional actions dispatched

      expect(logger).toHaveBeenCalledTimes(callIndex);
      expect(onSubmit).toHaveBeenCalled();
      expect(onSubmit).toHaveBeenCalledTimes(1);
      expect(onSubmit.mock.calls[0][0]).toEqualMap({
        foo: 'hello'
      });
      expect(typeof onSubmit.mock.calls[0][1]).toBe('function');
      expect(onSubmit.mock.calls[0][2].values).toEqualMap({
        foo: 'hello'
      });
    });
  });
};

describeForm('Form.plain', _plain.default, _redux.combineReducers, function () {
  return expect.extend(_expectations.default);
});
describeForm('Form.immutable', _immutable.default, _reduxImmutablejs.combineReducers, function () {
  return expect.extend(_expectations2.default);
});