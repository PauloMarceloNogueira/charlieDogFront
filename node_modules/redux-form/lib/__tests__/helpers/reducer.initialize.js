"use strict";

exports.__esModule = true;
exports.default = void 0;

var _actions = _interopRequireDefault(require("../../actions"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var initialize = _actions.default.initialize;

var describeInitialize = function describeInitialize(reducer, expect, _ref) {
  var fromJS = _ref.fromJS;
  return function () {
    it('should set initialize values on initialize on empty state', function () {
      var state = reducer(undefined, initialize('foo', {
        myField: 'initialValue'
      }));
      expect(state).toEqualMap({
        foo: {
          values: {
            myField: 'initialValue'
          },
          initial: {
            myField: 'initialValue'
          }
        }
      });
    });
    it('should allow initializing null values', function () {
      var state = reducer(undefined, initialize('foo', {
        bar: 'baz',
        dog: null
      }));
      expect(state).toEqualMap({
        foo: {
          values: {
            bar: 'baz',
            dog: null
          },
          initial: {
            bar: 'baz',
            dog: null
          }
        }
      });
    });
    it('should initialize nested values on initialize on empty state', function () {
      var state = reducer(undefined, initialize('foo', {
        myField: {
          subField: 'initialValue'
        }
      }));
      expect(state).toEqualMap({
        foo: {
          values: {
            myField: {
              subField: 'initialValue'
            }
          },
          initial: {
            myField: {
              subField: 'initialValue'
            }
          }
        }
      });
    });
    it('should initialize array values on initialize on empty state', function () {
      var state = reducer(undefined, initialize('foo', {
        myField: ['initialValue']
      }));
      expect(state).toEqualMap({
        foo: {
          values: {
            myField: ['initialValue']
          },
          initial: {
            myField: ['initialValue']
          }
        }
      });
    });
    it('should initialize array values with subvalues on initialize on empty state', function () {
      var state = reducer(undefined, initialize('foo', {
        accounts: [{
          name: 'Bobby Tables',
          email: 'bobby@gmail.com'
        }, {
          name: 'Sammy Tables',
          email: 'sammy@gmail.com'
        }]
      }));
      expect(state).toEqualMap({
        foo: {
          values: {
            accounts: [{
              name: 'Bobby Tables',
              email: 'bobby@gmail.com'
            }, {
              name: 'Sammy Tables',
              email: 'sammy@gmail.com'
            }]
          },
          initial: {
            accounts: [{
              name: 'Bobby Tables',
              email: 'bobby@gmail.com'
            }, {
              name: 'Sammy Tables',
              email: 'sammy@gmail.com'
            }]
          }
        }
      });
    });
    it('should set initialize values, making form pristine when initializing', function () {
      var state = reducer(fromJS({
        foo: {
          values: {
            myField: 'dirtyValue'
          },
          fields: {
            myField: {
              touched: true
            }
          }
        }
      }), initialize('foo', {
        myField: 'cleanValue'
      }));
      expect(state).toEqualMap({
        foo: {
          values: {
            myField: 'cleanValue'
          },
          initial: {
            myField: 'cleanValue'
          }
        }
      });
    });
    it('should set initialize values, and not remove registered fields', function () {
      var state = reducer(fromJS({
        foo: {
          registeredFields: {
            username: {
              name: 'username',
              type: 'Field',
              count: 1
            },
            password: {
              name: 'password',
              type: 'Field',
              count: 1
            }
          },
          values: {
            username: 'dirtyValue'
          },
          fields: {
            username: {
              touched: true
            }
          }
        }
      }), initialize('foo', {
        username: 'cleanValue',
        password: 'cleanPassword'
      }));
      expect(state).toEqualMap({
        foo: {
          registeredFields: {
            username: {
              name: 'username',
              type: 'Field',
              count: 1
            },
            password: {
              name: 'password',
              type: 'Field',
              count: 1
            }
          },
          values: {
            username: 'cleanValue',
            password: 'cleanPassword'
          },
          initial: {
            username: 'cleanValue',
            password: 'cleanPassword'
          }
        }
      });
    });
    it('should not retain submitSucceeded when keepSubmitSucceeded is not set', function () {
      var state = reducer(fromJS({
        foo: {
          submitSucceeded: true
        }
      }), initialize('foo', {}));
      expect(state).toEqualMap({
        foo: {
          values: {},
          initial: {}
        }
      });
    });
    it('should retain submitSucceeded when keepSubmitSucceeded is set', function () {
      var state = reducer(fromJS({
        foo: {
          submitSucceeded: true
        }
      }), initialize('foo', {}, {
        keepSubmitSucceeded: true
      }));
      expect(state).toEqualMap({
        foo: {
          values: {},
          initial: {},
          submitSucceeded: true
        }
      });
    });
    it('should retain dirty values when keepDirty is set', function () {
      var state = reducer(fromJS({
        foo: {
          registeredFields: {
            myField: {
              name: 'myField',
              type: 'Field',
              count: 1
            }
          },
          values: {
            myField: 'dirtyValue'
          },
          initial: {
            myField: 'initialValue'
          }
        }
      }), initialize('foo', {
        myField: 'newValue'
      }, true));
      expect(state).toEqualMap({
        foo: {
          registeredFields: {
            myField: {
              name: 'myField',
              type: 'Field',
              count: 1
            }
          },
          values: {
            myField: 'dirtyValue'
          },
          initial: {
            myField: 'newValue'
          }
        }
      });
    });
    it('should replace pristine values when keepDirty is set', function () {
      var state = reducer(fromJS({
        foo: {
          registeredFields: {
            myField: {
              name: 'myField',
              type: 'Field',
              count: 1
            }
          },
          values: {
            myField: 'initialValue'
          },
          initial: {
            myField: 'initialValue'
          }
        }
      }), initialize('foo', {
        myField: 'newValue'
      }, true));
      expect(state).toEqualMap({
        foo: {
          registeredFields: {
            myField: {
              name: 'myField',
              type: 'Field',
              count: 1
            }
          },
          values: {
            myField: 'newValue'
          },
          initial: {
            myField: 'newValue'
          }
        }
      });
    });
    it('should treat a matching dirty value as pristine when keepDirty is set', function () {
      var state = reducer(fromJS({
        foo: {
          registeredFields: {
            myField: {
              name: 'myField',
              type: 'Field',
              count: 1
            }
          },
          values: {
            myField: 'newValue'
          },
          initial: {
            myField: 'initialValue'
          }
        }
      }), initialize('foo', {
        myField: 'newValue'
      }, true));
      expect(state).toEqualMap({
        foo: {
          registeredFields: {
            myField: {
              name: 'myField',
              type: 'Field',
              count: 1
            }
          },
          values: {
            myField: 'newValue'
          },
          initial: {
            myField: 'newValue'
          }
        }
      });
    });
    it('allows passing keepDirty in options argument', function () {
      var state = reducer(fromJS({
        foo: {
          registeredFields: {
            myField: {
              name: 'myField',
              type: 'Field',
              count: 1
            }
          },
          values: {
            myField: 'dirtyValue'
          },
          initial: {
            myField: 'initialValue'
          }
        }
      }), initialize('foo', {
        myField: 'newValue'
      }, {
        keepDirty: true
      }));
      expect(state).toEqualMap({
        foo: {
          registeredFields: {
            myField: {
              name: 'myField',
              type: 'Field',
              count: 1
            }
          },
          values: {
            myField: 'dirtyValue'
          },
          initial: {
            myField: 'newValue'
          }
        }
      });
    });
    it('should persist warnings if they exist', function () {
      var state = reducer(fromJS({
        foo: {
          registeredFields: [{
            name: 'myField',
            type: 'Field'
          }],
          values: {
            myField: 'newValue'
          },
          initial: {
            myField: 'initialValue'
          },
          warning: 'form wide warning',
          syncWarnings: {
            myField: 'field warning'
          }
        }
      }), initialize('foo', {
        myField: 'newValue'
      }, true));
      expect(state).toEqualMap({
        foo: {
          registeredFields: [{
            name: 'myField',
            type: 'Field'
          }],
          values: {
            myField: 'newValue'
          },
          initial: {
            myField: 'newValue'
          },
          warning: 'form wide warning',
          syncWarnings: {
            myField: 'field warning'
          }
        }
      });
    });
    it('should persist errors if they exist', function () {
      var state = reducer(fromJS({
        foo: {
          registeredFields: [{
            name: 'myField',
            type: 'Field'
          }],
          values: {
            myField: 'newValue'
          },
          initial: {
            myField: 'initialValue'
          },
          error: 'form wide error',
          syncErrors: {
            myField: 'field error'
          }
        }
      }), initialize('foo', {
        myField: 'newValue'
      }, true));
      expect(state).toEqualMap({
        foo: {
          registeredFields: [{
            name: 'myField',
            type: 'Field'
          }],
          values: {
            myField: 'newValue'
          },
          initial: {
            myField: 'newValue'
          },
          error: 'form wide error',
          syncErrors: {
            myField: 'field error'
          }
        }
      });
    });
    it('should not insert null versions of objects into arrays for deleted indices', function () {
      var values = {
        myField: [{
          name: 'One'
        }]
      };
      var initial = {
        myField: [{
          name: 'One'
        }, {
          name: 'Two'
        }]
      };
      var registeredFields = {
        myField: {
          name: 'myField',
          type: 'Field',
          count: 1
        },
        'myField.0.name': {
          name: 'myField.0.name',
          type: 'Field',
          count: 1
        },
        'myField.1.name': {
          name: 'myField.1.name',
          type: 'Field',
          count: 0
        }
      };
      var state = reducer(fromJS({
        foo: {
          registeredFields: registeredFields,
          values: values,
          initial: initial
        }
      }), initialize('foo', initial, true));
      expect(state).toEqualMap({
        foo: {
          registeredFields: registeredFields,
          values: values,
          initial: initial
        }
      });
    });
    it('should update pristine values if keepDirty and updateUnregisteredFields, even if the field is not registered (yet)', function () {
      var values = {
        myField: [{
          name: 'One'
        }, {
          name: 'Two'
        }]
      };
      var initial = {
        myField: [{
          name: 'One'
        }, {
          name: 'Two'
        }]
      };
      var newInitial = {
        myField: [{
          name: 'One'
        }, {
          name: 'Two'
        }, {
          name: 'Three'
        }]
      };
      var registeredFields = {};
      var state = reducer(fromJS({
        foo: {
          registeredFields: registeredFields,
          values: values,
          initial: initial
        }
      }), initialize('foo', newInitial, true, {
        updateUnregisteredFields: true
      }));
      expect(state).toEqualMap({
        foo: {
          registeredFields: registeredFields,
          values: newInitial,
          initial: newInitial
        }
      });
    });
    it('should not create empty object if new initial value is an empty array and keepDirty is set', function () {
      var before = {
        myForm: {
          registeredFields: {
            myList: {
              name: 'myList',
              type: 'Field',
              count: 0
            },
            'myList.0.name': {
              name: 'myList.0.name',
              type: 'Field',
              count: 0
            }
          },
          values: {
            myList: []
          },
          initial: {
            myList: [{
              name: ''
            }]
          }
        }
      };
      var actionInitialValues = {
        myList: []
      };
      var actionKeepDirty = true;
      var state = reducer(fromJS(before), initialize('myForm', actionInitialValues, actionKeepDirty));
      expect(state).toEqualMap({
        myForm: {
          registeredFields: {
            myList: {
              name: 'myList',
              type: 'Field',
              count: 0
            },
            'myList.0.name': {
              name: 'myList.0.name',
              type: 'Field',
              count: 0
            }
          },
          values: {
            myList: []
          },
          initial: {
            myList: []
          }
        }
      }, null, 2);
    });
    it('should add new pristine values at the root level', function () {
      var newInitial = {
        oldField: 'oldValue',
        newField: 'newValue'
      };
      var registeredFields = {
        oldField: {
          name: 'oldField',
          type: 'Field',
          count: 1
        }
      };
      var state = reducer(fromJS({
        foo: {
          registeredFields: registeredFields,
          values: {
            oldField: 'oldValue'
          },
          initial: {
            oldField: 'oldValue'
          }
        }
      }), initialize('foo', newInitial, true));
      expect(state).toEqualMap({
        foo: {
          registeredFields: registeredFields,
          values: {
            oldField: 'oldValue',
            newField: 'newValue'
          },
          initial: newInitial
        }
      });
    });
    it('should add new pristine values at nested levels', function () {
      var newInitial = {
        group: {
          oldField: 'oldValue',
          newField: 'newValue'
        }
      };
      var registeredFields = {
        group: {
          name: 'group',
          type: 'Field',
          count: 1
        },
        'group.oldField': {
          name: 'group.oldField',
          type: 'Field',
          count: 1
        }
      };
      var state = reducer(fromJS({
        foo: {
          registeredFields: registeredFields,
          values: {
            group: {
              oldField: 'oldValue'
            }
          },
          initial: {
            group: {
              oldField: 'oldValue'
            }
          }
        }
      }), initialize('foo', newInitial, true));
      expect(state).toEqualMap({
        foo: {
          registeredFields: registeredFields,
          values: {
            group: {
              oldField: 'oldValue',
              newField: 'newValue'
            }
          },
          initial: newInitial
        }
      });
    });
    it('should keep initial values although new ones are added', function () {
      var initial = {
        existingField: 'existingValue'
      };
      var newInitial = {
        newField: 'newValue'
      };

      var expectedInitial = _extends({}, initial, newInitial);

      var state = reducer(undefined, initialize('foo', initial));
      var newState = reducer(state, initialize('foo', newInitial, {
        keepValues: true
      }));
      expect(newState).toEqualMap({
        foo: {
          initial: expectedInitial,
          values: expectedInitial
        }
      });
    });
    it('should keep old values add new pristine values at the root level', function () {
      var newInitial = {
        newField: 'newValue'
      };
      var registeredFields = {
        oldField: {
          name: 'oldField',
          type: 'Field',
          count: 1
        }
      };
      var state = reducer(fromJS({
        foo: {
          registeredFields: registeredFields,
          values: {
            oldField: 'oldValue'
          },
          initial: {
            oldField: 'oldValue'
          }
        }
      }), initialize('foo', newInitial, true, {
        keepValues: true
      }));
      expect(state).toEqualMap({
        foo: {
          registeredFields: registeredFields,
          values: {
            oldField: 'oldValue',
            newField: 'newValue'
          },
          initial: {
            oldField: 'oldValue',
            newField: 'newValue'
          }
        }
      });
    });
  };
};

var _default = describeInitialize;
exports.default = _default;